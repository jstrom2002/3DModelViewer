#include "structs.hpp"

namespace TDModelView 
{
	Shader* Renderer::defaultShader() 
	{
		Shader* shader = new Shader();
		const char* vert =
			"#version 330\n"
			"precision highp float;"
			"layout(location = 0) in vec3 vertexPosition;\n"
			"layout(location = 1) in vec3 vertexTexCoord;\n"
			"layout(location = 2) in vec3 vertexNormal;\n"
			"layout(location = 3) in vec3 vertexTangent;\n"
			"layout(location = 4) in vec3 vertexBitangent;\n"
			"uniform mat3 normalMatrix;\n"
			"uniform mat4 modelMatrix;\n"
			"uniform mat4 modelViewProjection;\n"
			"out Vertex{\n"
			"	vec3 position;\n"
			"	vec3 texCoord;\n"
			"	vec3 normal;\n"
			"	vec3 tangent;\n"
			"	vec3 bitangent;\n"
			"	vec3 TangentViewPos;\n"
			"	vec3 TangentFragPos;\n"
			"	vec3 TangentLightDir;\n"
			"};\n"
			"uniform struct Material {\n"
			"	vec3 diffuse;\n"
			"	vec3 specular;\n"
			"	vec3 ambient;\n"
			"	vec3 emissive;\n"
			"	vec3 transparent;\n"
			"	float specularFactor;\n"
			"	float roughness;\n"
			"	float opacity;\n"
			"	float ior;\n"
			"	float metalness;\n"
			"} material;\n"
			"layout(binding = 5) uniform sampler2D heightMap;\n"
			"uniform bool hasHeightMap = false;\n"
			"uniform vec3 heightMapTranslation = vec3(0);\n"
			"uniform vec3 heightMapScale = vec3(1);\n"
			"uniform float heightMapAmplitude = 1.0;\n"
			"uniform int heightMapUseChannel = 0;\n"
			"uniform bool hasNormalMap = false;\n"
			"layout(binding = 9) uniform sampler2D displacementMap;\n"
			"uniform bool hasDisplacementMap = false;\n"
			"uniform vec3 displacementMapTranslation = vec3(0);\n"
			"uniform vec3 displacementMapScale = vec3(1);\n"
			"uniform float displacementMapAmplitude = 1.f;\n"
			"uniform int displacementMapUseChannel = 0;\n"
			"uniform vec3 cameraPosition;\n"
			"uniform vec4 lightVec;\n"
			"vec3 TF(mat4 M, vec3 v){\n"
			"	vec4 v2 = M * vec4(v,1.0);\n"
			"	return v2.xyz / v2.w;"
			"}\n"
			"void main() {\n"
			"	vec4 vertexPos = vec4(vertexPosition, 1.0);\n"
			"	if (hasHeightMap) {\n"
			"		float heightVal = texture(heightMap, vertexTexCoord.xy).r;\n"
			"		heightVal = heightVal * 2.0 - 1.0;\n"//scale [0,1] ==> [-1,1]
			"		heightVal *= heightMapAmplitude;\n"
			"		vertexPos.xyz += heightVal * vertexNormal;\n"
			"	}\n"
			"	position = vec3(modelMatrix * vertexPos);\n"
			"	texCoord = vertexTexCoord;\n"
			"	normal = normalize(mat3(modelMatrix) * vertexNormal.rgb);\n"
			"	tangent = normalize(mat3(modelMatrix) * vertexTangent.rgb);\n"
			"	bitangent = normalize(mat3(modelMatrix) * vertexBitangent.rgb);\n"
			"	if(hasNormalMap){"
			"	normal = normalize(normalMatrix* vertexNormal.rgb);\n"
			"	tangent = normalize(normalMatrix* vertexTangent.rgb);\n"
			"	tangent = normalize(tangent - dot(tangent, normal) * normal);\n"
			"	float handedness_fix = (dot(vertexNormal.rgb, cross(vertexTangent.rgb, vertexBitangent.rgb)) > 0.0f) ? 1.0f : -1.0f;\n"
			"	bitangent = normalize(handedness_fix * cross(normal,tangent));\n"
			"	}"
			//"	if (hasDisplacementMap) {\n"
			"		mat3 TBN = transpose(mat3(tangent, bitangent, normal));\n"
			"		TangentViewPos = TBN * cameraPosition;\n"
			"		TangentFragPos = TBN * position;\n"
			"		TangentLightDir = TBN * lightVec.rgb;\n"
			//"	}\n"
			"	gl_Position = modelViewProjection * vertexPos;\n"
			"}\n";

		const char* frag =
			"#version 330\n"
			"precision highp float;"
			"out vec4 fragColor;\n"
			"in Vertex{\n"
			"	vec3 position;\n"
			"	vec3 texCoord;\n"
			"	vec3 normal;\n"
			"	vec3 tangent;\n"
			"	vec3 bitangent;\n"
			"	vec3 TangentViewPos;\n"
			"	vec3 TangentFragPos;\n"
			"	vec3 TangentLightDir;\n"
			"};\n"
			"uniform mat3 normalMatrix;\n"
			"uniform mat4 modelMatrix;\n"
			"uniform mat4 modelViewProjection;\n"
			"uniform struct Material {\n"
			"	vec3 diffuse;\n"
			"	vec3 specular;\n"
			"	vec3 ambient;\n"
			"	vec3 emissive;\n"
			"	vec3 transparent;\n"
			"	float specularFactor;\n"
			"	float roughness;\n"
			"	float opacity;\n"
			"	float ior;\n"
			"	float metalness;\n"
			"} material;\n"
			"layout(binding = 1) uniform sampler2D diffuseMap;\n"
			"uniform bool hasDiffuseMap = false;\n"
			"layout(binding = 2) uniform sampler2D specularMap;\n"
			"uniform bool hasSpecularMap = false;\n"
			"layout(binding = 3) uniform sampler2D ambientMap;\n"
			"uniform bool hasAmbientMap = false;\n"
			"layout(binding = 4) uniform sampler2D emissiveMap;\n"
			"uniform bool hasEmissiveMap = false;\n"
			"layout(binding = 6) uniform sampler2D normalsMap;\n"
			"uniform bool hasNormalMap = false;\n"
			"uniform bool useBumpMap = false;\n"
			"layout(binding = 7) uniform sampler2D shininessMap;\n"
			"uniform bool hasShininessMap = false;\n"
			"layout(binding = 8) uniform sampler2D opacityMap;\n"
			"uniform bool hasOpacityMap = false;\n"
			"layout(binding = 9) uniform sampler2D displacementMap;\n"
			"uniform bool hasDisplacementMap = false;\n"
			"uniform float displacementMapAmplitude = 1.f;\n"
			"uniform float displacementMapBias = 0.f;\n"
			"layout(binding = 11) uniform sampler2D reflectionMap;\n"
			"uniform bool hasReflectionMap = false;\n"
			"layout(binding = 12) uniform sampler2D albedoMap;\n"
			"uniform bool hasAlbedoMap = false;\n"
			"layout(binding = 14) uniform sampler2D emissivecolorMap;\n"
			"uniform bool hasEmissiveColorMap = false;\n"
			"layout(binding = 15) uniform sampler2D metalnessMap;\n"
			"uniform bool hasMetalnessMap = false;\n"
			"layout(binding = 16) uniform sampler2D roughnessMap;\n"
			"uniform bool hasRoughnessMap = false;\n"
			"layout(binding = 17) uniform sampler2D ambientocclusionMap;\n"
			"uniform bool hasAmbientOcclusionMap = false;\n"
			"layout(binding = 18) uniform sampler2D brdfLUT;\n"
			"layout(binding = 19) uniform sampler2D irradianceMap;\n"
			"layout(binding = 20) uniform sampler2D prefilt;\n"
			"uniform float alphaCutoff = 0.01f;\n"
			"uniform int parallaxSamples = 10;\n"
			"uniform vec3 cameraPosition;\n"
			"uniform vec4 lightVec;\n"
			"uniform vec2 resolution;\n"
			"uniform float ambientLightBlend = 1.0f;\n"
			"uniform float aoStrength = 1.0f;\n"
			"uniform float reflectionStrength = 1.0f;\n"
			"vec3 specularReflection(vec3 R0, vec3 R90, float VdH){return R0 + (R90 - R0) * pow(clamp(1.0 - VdH, 0.0, 1.0), 5.0);}\n"
			"float geometricOcclusion(float NdL, float NdV, float r) {return (2.0 * NdL / (NdL + sqrt(r * r + (1.0 - r * r) * (NdL * NdL)))) * (2.0 * NdV / (NdV + sqrt(r * r + (1.0 - r * r) * (NdV * NdV))));}\n"
			"float microfacetDistribution(float rough2, float NdH) { float f = (NdH * rough2 - NdH) * NdH + 1.0; return rough2 / (3.14159265359f * f * f); }\n"
			"vec3 ACES(vec3 x){return (x*(2.51f*x+0.03f))/(x*(2.43f*x+0.59f)+0.14f);}\n"
			"vec3 bumpMapping(vec2 texCoord2) {\n"
			"	float bumpVal = texture(normalsMap, texCoord2).r;\n"
			"	vec3 tNormal = vec3(dFdx(bumpVal), dFdy(bumpVal), 0.0);\n"
			"	tNormal.z = 1.0 - tNormal.x - tNormal.y;\n"
			"	tNormal = 2.0 * tNormal - 1.0;\n"
			"	tNormal = length(tNormal) > 0.001f ? tNormal : normal;\n"//sanity check to prevent null vector.
			"	return tNormal;\n"
			"}\n"
			"vec3 normalMapping(vec2 texCoord2) {\n"
			"	vec3 tNormal = normalize(2.0f * texture(normalsMap, texCoord2).rgb - 1.0f);\n"
			"	return normalize(mat3(normalize(tangent), normalize(bitangent), tNormal) * tNormal);\n"//sanity check to prevent null vector.
			"}\n"
			"vec2 parallax() {\n"
			"	vec3 viewDir = normalize(TangentViewPos - TangentFragPos);\n"
			"	const float minLayers = 8;\n"
			"	float numLayers = mix(parallaxSamples, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));\n"
			"	float layerDepth = 1.0 / numLayers;\n"
			"	float currentLayerDepth = 0.0;\n"
			"	vec2 P = (viewDir.xy - displacementMapBias) / viewDir.z * displacementMapAmplitude;\n"
			"	vec2 deltaTexCoords = P / numLayers;\n"
			"	vec2  currentTexCoords = texCoord.xy;\n"
			"	float currentDepthMapValue = texture(displacementMap, texCoord.xy).r;\n"
			"	while (currentLayerDepth < currentDepthMapValue) {\n"
			"		currentTexCoords -= deltaTexCoords;\n"
			"		currentDepthMapValue = texture(displacementMap, currentTexCoords.xy).r;\n"
			"		currentLayerDepth += layerDepth;\n"
			"	}\n"
			"	vec2 prevTexCoords = currentTexCoords + deltaTexCoords;\n"
			"	float afterDepth = currentDepthMapValue - currentLayerDepth;\n"
			"	float beforeDepth = texture(displacementMap, prevTexCoords.xy).r - currentLayerDepth + layerDepth;\n"
			"	float weight = afterDepth / (afterDepth - beforeDepth);\n"
			"	vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);\n"
			"	return finalTexCoords;\n"
			"}\n"
			"vec2 cartesianToPolar(vec3 worldPos) {\n"
			"	float n = length(worldPos.xz);\n"
			"	vec2 pos = vec2((n > 0.0000001) ? worldPos.x / n : 0.0, worldPos.y);\n"
			"	pos = acos(pos) * 0.31831;\n"
			"	pos.x = (worldPos.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);\n"
			"	pos.x = 1.0 - pos.x;\n"
			"	return pos;\n"
			"}\n"
			"void getIBLContribution(inout vec3 IBL_d, inout vec3 IBL_s, float NdV, float rough, float metal, vec3 n, vec3 reflection, vec3 diff, vec3 spec){\n"//See: https://github.com/oframe/ibl-converter/blob/master/src/shaders/PBRShader.js
			"	vec2 brdf = vec2(1.0f);\n"//pow(texture(brdfLUT, vec2(NdV, rough)).rg, vec2(1.0f/2.2f));\n"
			"	float blend = rough * 6.0f;\n"// Sample 2 levels and mix between to get smoother degradation
			"	float level0 = floor(blend); \n"
			"	float level1 = min(6.0f, level0 + 1.0);\n"
			"	blend -= level0;\n"				
			"	vec2 uvSpec = cartesianToPolar(reflection);\n"// Sample the specular env map atlas depending on the roughness value
			"	uvSpec.y /= 2.0;\n"
			"	vec2 uv0 = uvSpec;\n"
			"	vec2 uv1 = uvSpec;\n"
			"	uv0 /= pow(2.0f, level0);\n"
			"	uv0.y += 1.0 - exp(-0.6931472 * level0);\n"
			"	uv1 /= pow(2.0f, level1);\n"
			"	uv1.y += 1.0 - exp(-0.6931472 * level1);\n"
			"	IBL_d = ambientLightBlend * textureLod(irradianceMap, cartesianToPolar(n), 1.0f).rgb * diff;\n"
			"	float reflectivity = pow((1.0 - rough), 2.0) * 0.5;\n"// Bit of extra reflection for smooth materials
			"	vec3 specularLight = mix(pow(textureLod(prefilt, uv0, 1.0f).rgb, vec3(1.0f)).rgb, pow(textureLod(prefilt, uv1, 1.0f).rgb, vec3(1.0f)).rgb, blend);\n"
			"	IBL_s = reflectionStrength * specularLight * (spec * brdf.x + brdf.y + reflectivity);\n"
			"	IBL_s = mix(IBL_s,vec3(0.0),rough);\n"
			"}\n"
			"float max3(vec3 v){ return max(max(v.x,v.y),v.z); }\n"
			"void main() {\n"
			"	vec2 newTexCoord = texCoord.xy;\n"
			"	if (hasDisplacementMap) {\n" // Apply parallax effect.
			"		newTexCoord = parallax();\n"
			"	}\n"
			"	vec4 diffuseColor = vec4(material.diffuse, 1.0);\n"
			"	if (hasAlbedoMap) {\n"
			"		vec4 dif = texture(albedoMap, newTexCoord);\n"
			"		diffuseColor *= dif;\n"
			"	}\n"
			"	else if (hasDiffuseMap) {\n"
			"		vec4 dif = texture(diffuseMap, newTexCoord);\n"
			"		diffuseColor *= dif;\n"
			"	}\n"
			"	float opacityVal = min(material.opacity, diffuseColor.a);\n"
			"	if (hasOpacityMap) {\n"
			"		opacityVal = texture(opacityMap, newTexCoord).r;\n"
			"	}\n"
			"	if (opacityVal <= alphaCutoff) {\n"
			"		discard;\n"
			"		return;\n"
			"	}\n"
			"	vec4 gAlbedo = vec4(diffuseColor.rgb, opacityVal);\n"
			"	if(gAlbedo.a <= 0.0f){ discard; return; }\n" // Do transparency fragment discard here
			"	vec4 specularColor = vec4(material.specular, material.specularFactor);\n"
			"	if (hasSpecularMap) {\n"
			"		vec4 spec = texture(specularMap, newTexCoord);\n"
			"		specularColor.rgb *= spec.rgb;\n"
			"	}\n"
			"	vec4 gSpecular = vec4(specularColor.rgb, specularColor.a);\n"
			"	vec3 nml = normalize(normal);\n"
			"	if (useBumpMap)\n"
			"		nml = bumpMapping(newTexCoord).xyz;\n"
			"	else if (hasNormalMap)\n"
			"		nml = normalMapping(newTexCoord).xyz;\n"
			"	vec3 emissiveColor = material.emissive;\n"
			"	if (hasEmissiveColorMap) {\n"
			"		emissiveColor = texture(emissivecolorMap,newTexCoord).rgb;\n"
			"		if (hasEmissiveMap){\n"
			"			vec3 emis = texture(emissiveMap,newTexCoord).rgb;\n"
			"			emissiveColor *= emis;\n"
			"		}\n"
			"	}\n"
			"	else if (hasEmissiveMap)\n"
			"		emissiveColor = texture(emissiveMap,newTexCoord).rgb;\n"
			"	float ao = 1.0;\n"
			"	if (hasAmbientOcclusionMap) {\n"
			"		ao = texture(ambientocclusionMap, newTexCoord).r;\n"
			"	}\n"
			"	float rough = material.roughness;\n"
			"	if (hasShininessMap){\n"
			"		rough = max(1.0f - texture(shininessMap, newTexCoord).r, 0.0f);\n"
			"	}\n"
			"	else if (hasRoughnessMap) {\n"
			"		rough = texture(roughnessMap, newTexCoord).r;\n"
			"	}\n"
			"	float metalness = material.metalness;\n"
			"	if (hasMetalnessMap){\n"
			"		metalness = max(texture(metalnessMap, newTexCoord).r, 0.0f);\n"
			"	}\n"
			"	float ior = clamp(material.ior, 1.0f, 50.0f);\n"
			"	rough = clamp(rough, 0.04f, 1.0f);\n"
			"	metalness = clamp(metalness, 0.04f, 1.0f);\n"

			// Lighting section
			"	vec3 N = nml;\n"
			"	vec3 V = normalize(cameraPosition - position);\n"
			"	vec3 L = normalize(lightVec.rgb);\n"
			"	if(hasNormalMap){"
			"		V = normalize(TangentViewPos - TangentFragPos)\n;"
			"		L = normalize(TangentLightDir);\n"
			"	}"
			"	vec3 H = normalize(L + V);\n"
			"	float NdotL =  max(dot(N, L), 0.0f);\n"
			"	float NdotV =  max(dot(N, V), 0.0f);\n"
			"	float NdotH =  max(dot(N, H), 0.0f);\n"
			"	float LdotV =  max(dot(L, V), 0.0f);\n"
			"	float LdotH =  max(dot(L, H), 0.0f);\n"
			"	float VdotH =  max(dot(V, H), 0.0f);\n"

			// Calculate Fresnel reflectance at 0 and 90 angles. Metal-rough workflow, use ior for reflectance.
			"vec3 F0 = mix(vec3(0.04), vec3(max3(gAlbedo.rgb)), metalness);\n"
			"vec3 diffColor = mix(gAlbedo.rgb, vec3(0.0), metalness);\n"
			"vec3 specColor = mix(F0, gAlbedo.rgb, metalness);\n"
			"vec3 specularEnvR0 = specColor;\n"
			"vec3 specularEnvR90 = vec3(clamp(max(max(specColor.r, specColor.g), specColor.b) * 25.0, 0.0, 1.0)); \n"

			// Direct light calc.
			"vec3 F = specularReflection(specularEnvR0, specularEnvR90, VdotH);\n"
			"float G = geometricOcclusion(NdotL, NdotV, rough);\n"
			"float D = microfacetDistribution(rough, NdotH);\n"
			"vec3 diffuseContrib = (1.0 - F) * (diffColor / 3.14159265359f);\n"
			"vec3 specContrib = F * G * D / (4.0f * NdotL * NdotV + 0.001f);\n"
			"vec3 result = NdotL * lightVec.a * (diffuseContrib + specContrib);\n"

			// Get ambient light, irradiance.
			"vec3 IBL_d=vec3(0.0);\n"
			"vec3 IBL_s=vec3(0.0);\n"
			"float aoVal = mix(1.0f, ao, aoStrength);\n"
			"if(aoVal > 0.001f) { getIBLContribution(IBL_d,IBL_s,NdotV,rough,metalness,nml,normalize(reflect(-V, N)),diffColor,specColor); }\n"
			"result += (IBL_d + IBL_s) * aoVal;\n"
			"result += emissiveColor;\n"

			"	fragColor = vec4(ACES(result), opacityVal);\n"
			"}\n";

		// Compile vertex shader.
		char infoLog[1024];
		unsigned int vert_id = glCreateShader(GL_VERTEX_SHADER);
		glShaderSource(vert_id, 1, &vert, NULL);
		glCompileShader(vert_id);
		int success;
		glGetShaderiv(vert_id, GL_COMPILE_STATUS, &success);
		if (!success) {
			glGetShaderInfoLog(vert_id, 1024, NULL, infoLog);
			std::string errorStr = std::string(infoLog);
			ErrorMessageBox(errorStr);
		}

		// Compile frag shader.
		unsigned int frag_id = glCreateShader(GL_FRAGMENT_SHADER);
		glShaderSource(frag_id, 1, &frag, NULL);
		glCompileShader(frag_id);
		glGetShaderiv(frag_id, GL_COMPILE_STATUS, &success);
		if (!success) {
			glGetShaderInfoLog(frag_id, 1024, NULL, infoLog);
			std::string errorStr = std::string(infoLog);
			ErrorMessageBox(errorStr);
		}

		// Attach and compile all.
		shader->handle = "defaultShader";
		shader->ID = glCreateProgram();
		glAttachShader(shader->ID, vert_id);
		glAttachShader(shader->ID, frag_id);
		glLinkProgram(shader->ID);
		shader->checkCompileErrors(shader->ID, "defaultShader");

		// Cleanup.
		glDeleteShader(vert_id);
		glDeleteShader(frag_id);
		return shader;
	}
}